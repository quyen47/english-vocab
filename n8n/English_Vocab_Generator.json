{
  "name": "English Vocab Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-vocab",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "3cf1db4e-9788-41ae-b64f-91a32a446c95",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -224,
        -128
      ],
      "webhookId": "generate-vocab"
    },
    {
      "parameters": {
        "jsCode": "// Parse Gemini response and extract the JSON\nconst input = $input.first();\nlet content;\n\ntry {\n  // Gemini returns: candidates[0].content.parts[0].text\n  let rawText;\n  const d = input.json;\n  if (d.candidates && d.candidates[0]?.content?.parts?.[0]?.text) {\n    rawText = d.candidates[0].content.parts[0].text;\n  } else {\n    rawText = d.output || d.message?.content || d.text || JSON.stringify(d);\n  }\n\n  if (typeof rawText === 'string') {\n    const cleaned = rawText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n    content = JSON.parse(cleaned);\n  } else {\n    content = rawText;\n  }\n} catch (e) {\n  const d = input.json;\n  let fallback = '';\n  if (d.candidates && d.candidates[0]?.content?.parts?.[0]?.text) {\n    fallback = d.candidates[0].content.parts[0].text;\n  } else {\n    fallback = d.output || d.message?.content || d.text || '';\n  }\n  const jsonMatch = String(fallback).match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    content = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('Could not parse Gemini response: ' + String(fallback).substring(0, 500));\n  }\n}\n\nif (!content.id || !content.type || !content.words || !content.memory_logic) {\n  throw new Error('Missing required fields. Got keys: ' + Object.keys(content).join(', '));\n}\n\nreturn [{ json: content }];"
      },
      "id": "9a52f033-cadb-4d06-9513-46c9a1571c7c",
      "name": "Parse & Validate JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        -128
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "524a1d7b-e210-4f9a-995e-8e727825ea2c",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        496,
        -128
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ error: $json.message || 'Generation failed' }) }}",
        "options": {
          "responseCode": 500,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "e81bad97-25c3-42e6-9e35-7d9a5f2cf2f2",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        496,
        96
      ]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "models/gemini-2.5-flash",
          "mode": "list",
          "cachedResultName": "models/gemini-2.5-flash"
        },
        "messages": {
          "values": [
            {
              "content": "=You are an expert English language teacher specializing in etymology and morphology. You help Vietnamese learners understand English vocabulary through word roots, prefixes, and suffixes.\n\nGenerate vocabulary content for the {{ $json.body.type }} \"{{ $json.body.morpheme }}\".\n\nRules:\n1. Generate 4-6 common English words that use this {{ $json.body.type }}.\n2. Group words by CEFR level (B1, B2, C1).\n3. For each word, provide:\n   - Morphological breakdown (e.g., \"con- + struct\")\n   - Each part's meaning in Vietnamese + English\n   - A logic chain explaining how the parts combine to form the meaning (in Vietnamese)\n   - English meaning + Vietnamese translation\n   - One clear example sentence\n   - 3 common collocations with example sentences\n   - 2-3 word forms (noun, verb, adj, adv) with example sentences\n4. Create a memory logic table summarizing how each prefix/suffix combines with the {{ $json.body.type }}.\n\nYou MUST respond with ONLY valid JSON (no markdown, no explanation outside JSON). Use this exact structure:\n\n{\n  \"id\": \"{{ $json.body.morpheme }}\",\n  \"type\": \"{{ $json.body.type }}\",\n  \"meaning\": \"<core meaning in English>\",\n  \"origin\": \"<etymology, e.g. Latin: struere>\",\n  \"explanation\": \"<2-3 sentence explanation using **bold** for key terms>\",\n  \"level_note\": \"<one line noting CEFR level range>\",\n  \"words\": [\n    {\n      \"word\": \"<the vocabulary word>\",\n      \"level\": \"B1\",\n      \"breakdown\": \"<e.g. con- + struct>\",\n      \"parts\": [\n        { \"part\": \"<prefix/root/suffix>\", \"meaning\": \"<Vietnamese meaning> (<English meaning>)\" }\n      ],\n      \"logic\": \"<Vietnamese logic chain>\",\n      \"meaning_vi\": \"<Vietnamese meaning>\",\n      \"meaning_en\": \"<English meaning>\",\n      \"example\": \"<example sentence>\",\n      \"collocations\": [\n        { \"phrase\": \"<collocation>\", \"example\": \"<example sentence>\" }\n      ],\n      \"forms\": [\n        { \"word\": \"<word form>\", \"type\": \"<n|v|adj|adv>\", \"example\": \"<example sentence>\" }\n      ]\n    }\n  ],\n  \"memory_logic\": {\n    \"root\": \"{{ $json.body.morpheme }}\",\n    \"meaning\": \"<core meaning>\",\n    \"table\": [\n      { \"prefix\": \"<prefix used>\", \"prefix_meaning\": \"<Vietnamese meaning>\", \"result\": \"<resulting word>\" },\n      { \"suffix\": \"<suffix used>\", \"suffix_meaning\": \"<Vietnamese meaning>\", \"result\": \"<resulting word(s)>\" }\n    ]\n  }\n}\n\nIMPORTANT:\n- All Vietnamese text must use proper diacritics (e.g., xây dựng, hướng dẫn, cấu trúc)\n- Respond with ONLY the raw JSON object, no markdown code fences, no explanation\n- The memory_logic.table should have entries for prefixes (with prefix and prefix_meaning keys) and suffixes (with suffix and suffix_meaning keys), each with a result key"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.googleGemini",
      "typeVersion": 1.1,
      "position": [
        -48,
        -128
      ],
      "id": "523217a8-2abe-47e0-a334-fc3ff65980a1",
      "name": "Message a model",
      "credentials": {
        "googlePalmApi": {
          "id": "7uOEKdy9M4NkQF7v",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Validate JSON": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Parse & Validate JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "90f68289-f33d-4c3c-9296-339166e143c8",
  "meta": {
    "instanceId": "ceb61508a604f092c6f654129f0f013334a4ca22d34ce46dfc090cc80257323f"
  },
  "id": "YpSpA1XLt33i82PG",
  "tags": []
}